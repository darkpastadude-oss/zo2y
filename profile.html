<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Profile | Zo2y</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Your existing CSS remains the same */
    :root {
      --bg: #0b1633; --card: #132347; --muted: #cbd5e1; --accent: #f59e0b; --accent-light: #3a2a1a;
      --glass: rgba(255,255,255,0.03); --white: #ffffff; --border: rgba(255,255,255,0.1); --shadow: rgba(0,0,0,0.3);
      --gradient: linear-gradient(135deg, #f59e0b 0%, #ffb84d 100%);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Poppins', sans-serif; 
      background-color: var(--bg); 
      color: var(--white); 
      line-height: 1.6;
      min-height: 100vh;
    }
    
    /* Your existing CSS styles remain unchanged */
    /* ... (all your existing CSS) ... */
    
  </style>
</head>
<body>
  <header>
    <img src="images/logo.png" alt="Zo2y" class="logo" onclick="location.href='index.html'">
    <div class="header-actions">
      <button class="back-btn" id="backButton" style="display: none;" onclick="goBack()">‚Üê Back</button>
      <button class="logout-btn" id="logoutBtn">Logout</button>
    </div>
  </header>

  <div class="profile-container" id="profileContainer">
    <!-- Profile Header -->
    <div class="profile-header">
      <div class="avatar" id="avatar"></div>
      <div class="profile-info">
        <div class="username" id="username">Loading...</div>
        <div class="email" id="email"></div>
        <div class="join-date" id="joinDate"></div>
        <button class="follow-btn" id="followButton" style="display: none;"></button>
        
        <!-- Stats -->
        <div class="profile-stats">
          <div class="stat-card" onclick="friendSystem.showFollowers()">
            <span class="stat-number" id="followersCount">0</span>
            <span class="stat-label">Followers</span>
          </div>
          <div class="stat-card" onclick="friendSystem.showFollowing()">
            <span class="stat-number" id="followingCount">0</span>
            <span class="stat-label">Following</span>
          </div>
          <div class="stat-card" onclick="friendSystem.showRequests()">
            <span class="stat-number" id="requestsCount">0</span>
            <span class="stat-label">Requests</span>
          </div>
        </div>
      </div>
    </div>

    <div class="profile-content">
      <!-- Left Column -->
      <div class="left-column">
        <!-- Bio Section -->
        <div class="bio">
          <div class="section-header">
            <h3>About Me</h3>
            <button class="edit-btn" id="editBioBtn">Edit Bio</button>
          </div>
          <div id="bioDisplay">
            <p id="bioText">No bio yet. Click edit to add one!</p>
          </div>
          <div id="bioEdit" style="display: none;">
            <textarea class="bio-textarea" id="bioTextarea" placeholder="Tell us about yourself..."></textarea>
            <div class="bio-actions">
              <button class="cancel-btn" id="cancelBioBtn">Cancel</button>
              <button class="save-btn" id="saveBioBtn">Save Bio</button>
            </div>
          </div>
        </div>

        <!-- Lists Section -->
        <div class="lists-section">
          <div class="section-header">
            <h3>My Lists</h3>
          </div>
          
          <div class="list-grid">
            <div class="list-card" onclick="showList('favorites')">
              <div class="list-icon">‚ù§Ô∏è</div>
              <div class="list-card-title">Favorites</div>
              <div class="list-card-count" id="favoritesCount">0 restaurants</div>
            </div>
            <div class="list-card" onclick="showList('visited')">
              <div class="list-icon">üçΩÔ∏è</div>
              <div class="list-card-title">Visited</div>
              <div class="list-card-count" id="visitedCount">0 restaurants</div>
            </div>
            <div class="list-card" onclick="showList('wantToGo')">
              <div class="list-icon">üìç</div>
              <div class="list-card-title">Want to Go</div>
              <div class="list-card-count" id="wantToGoCount">0 restaurants</div>
            </div>
          </div>

          <!-- Private Message -->
          <div class="private-message" id="privateMessage" style="display: none;">
            <div>üîí</div>
            <h3>Private Account</h3>
            <p>This account is private. Send a follow request to see their lists.</p>
          </div>

          <!-- Active List Display -->
          <div id="activeListSection" class="active-list-section" style="display: none;">
            <button class="back-btn" onclick="hideActiveList()">‚Üê Back to Lists</button>
            <h3 id="activeListTitle">My List</h3>
            <div id="activeListGrid" class="restaurants-grid"></div>
          </div>
        </div>
      </div>

      <!-- Right Column - Social -->
      <div class="social-section">
        <div class="section-header">
          <h3>Social</h3>
        </div>

        <!-- Privacy Settings -->
        <div class="privacy-toggle">
          <label class="toggle-switch">
            <input type="checkbox" id="privacyToggle">
            <span class="toggle-slider"></span>
          </label>
          <span class="privacy-label" id="privacyLabel">Public Account</span>
        </div>

        <!-- Search Users -->
        <div class="search-bar">
          <input type="text" class="search-input" id="userSearch" placeholder="Search users...">
          <button class="search-btn" onclick="friendSystem.searchUsers()">Search</button>
        </div>

        <!-- User Lists -->
        <div id="userLists" class="user-list">
          <div class="empty-state">
            <div>üîç</div>
            <p>Search for users to find friends</p>
            <p>Connect with other food lovers!</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom Notification -->
  <div id="customNotification" class="custom-notification">
    <i class="notification-icon"></i>
    <span class="notification-message"></span>
  </div>

  <script>
    const supabaseUrl = "https://gfkhjbztayjyojsgdpgk.supabase.co";
    const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdma2hqYnp0YXlqeW9qc2dkcGdrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwOTYyNjQsImV4cCI6MjA3NTY3MjI2NH0.WUb2yDAwCeokdpWCPeH13FE8NhWF6G8e6ivTsgu6b2s";
    const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

    let currentUser = null;
    let userProfile = null;
    let targetUser = null;
    let targetUserId = null;
    let currentActiveList = null;
    let isViewingOwnProfile = true;
    let currentSocialView = 'search'; // Track current social view

    // Restaurant Data
    const restaurants = [
      { id: 1, slug:'mori', name:'Mori Sushi', category:'Asian', desc:'Modern sushi chain serving rolls, sashimi & Japanese bites.', rating:4.7, image: 'mori.png' },
      { id: 2, slug:'kilo', name:'Kilo Kebab', category:'Middle Eastern', desc:'Charcoal-grilled kebabs & hearty Middle Eastern plates.', rating:4.5, image: 'kilo.png' },
      { id: 3, slug:'hameed', name:'Hameed', category:'Fast Food', desc:'Local favorite for sandwiches & quick bites.', rating:4.3, image: 'hameed.png' },
      { id: 4, slug:'bazooka', name:'Bazooka', category:'Burgers', desc:'Loaded burgers & crispy fried chicken combos.', rating:4.2, image: 'bazooka.jpg' },
      { id: 5, slug:'mexican', name:'Mexican Corn', category:'Mexican', desc:'Elote, tacos & cheesy Mexican street snacks.', rating:4.0, image: 'mexican.jpg' },
      { id: 6, slug:'chikin', name:'Chikin Worx', category:'Chicken', desc:'Crunchy chicken, sandwiches & family buckets.', rating:4.5, image: 'chikin.png' },
      { id: 7, slug:'vasko', name:'Vasko', category:'Cafe & Bakery', desc:'Artisanal coffee and pastries in a modern European-style cafe.', rating:4.6, image: 'vasko.jpg' },
      { id: 8, slug:'secondcup', name:'Second Cup', category:'Cafe & Bakery', desc:'Canadian coffeehouse serving espresso, lattes & pastries.', rating:4.4, image: 'secondcup.png' },
      { id: 9, slug:'station', name:'Pizza Station', category:'Pizza', desc:'Classic pizzas & comfort food.', rating:4.3, image: 'station.png' },
      { id: 10, slug:'brgr', name:'BRGR', category:'Burgers', desc:'Gourmet burgers with premium toppings & sides.', rating:4.4, image: 'brgr.jpg' },
      { id: 11, slug:'country', name:'Country Hills', category:'Fast Food', desc:'Grilled meats, casual dining & family meals.', rating:4.2, image: 'country.jpg' },
      { id: 12, slug:'bayoki', name:'Bayouki Rotisserie', category:'Chicken', desc:'Authentic grilled chicken & rotisserie meals.', rating:4.3, image: 'bayoki.png' },
      { id: 13, slug:'maine', name:'Maine', category:'Burgers', desc:'Premium burger joint serving juicy burgers, loaded fries & classic American comfort food.', rating:4.5, image: 'maine.jpg' },
      { id: 14, slug:'barbar', name:'Barbar Shawarma', category:'Middle Eastern', desc:'Iconic shawarma spot serving beef, chicken & falafel.', rating:4.4, image: 'barbar.png' },
      { id: 15, slug:'labash', name:'Labash', category:'Chicken', desc:'Known for charcoal-grilled chicken, meat & fast bites.', rating:4.3, image: 'labash.jpg' },
      { id: 16, slug:'pickl', name:'Pickl Egypt', category:'Burgers', desc:'Dubai\'s famous burger chain now in Egypt ‚Äî loaded burgers, crispy chicken & shakes.', rating:4.6, image: 'pickl.jpg' },
      { id: 17, slug:'akleh', name:'Akleh', category:'Middle Eastern', desc:'Authentic Lebanese mezze, grills & traditional dishes.', rating:4.4, image: 'akleh.jpg' },
      { id: 18, slug:'howlin', name:'Howlin\' Birds', category:'Chicken', desc:'Nashville-style hot chicken sandwiches & tenders.', rating:4.5, image: 'howlin.png' },
      { id: 19, slug:'sauce', name:'Sauce', category:'Burgers', desc:'Trendy burgers & loaded fries; street food vibes.', rating:4.4, image: 'sauce.jpg' },
      { id: 20, slug:'papa', name:'Pappa Roti', category:'Cafe & Bakery', desc:'Famous for their signature coffee buns and artisanal baked goods.', rating:4.5, image: 'papa.png' },
      { id: 21, slug:'qasr', name:'Qasr El Kababgy', category:'Middle Eastern', desc:'Elegant dining experience with authentic Middle Eastern cuisine.', rating:4.8, image: 'qasr.png' },
      { id: 22, slug:'heart', name:'Heart Attack', category:'Chicken', desc:'Bold, flavorful fried chicken with signature spicy sauces and crispy perfection.', rating:4.3, image: 'heart.jpg' },
      { id: 23, slug:'what', name:'What The Crust', category:'Pizza', desc:'Creative pizza combinations with unique crust options and gourmet toppings.', rating:4.4, image: 'what.png' },
      { id: 24, slug:'buffalo', name:'Buffalo Burger', category:'Burgers', desc:'Juicy buffalo burgers with classic American flavors and premium ingredients.', rating:4.5, image: 'buffalo.jpg' },
      { id: 25, slug:'mince', name:'Mince', category:'Burgers', desc:'Artisanal burgers made with freshly minced beef and creative flavor combinations.', rating:4.6, image: 'mince.jpg' },
      { id: 26, slug:'88', name:'Pizza 88', category:'Pizza', desc:'Delicious pizzas with fresh ingredients and perfect crust.', rating:4.3, image: '88.jpg' },
      { id: 27, slug:'kansas', name:'Kansas Chicken', category:'Chicken', desc:'Crispy fried chicken with signature spices and family meal options.', rating:4.4, image: 'kansas.png' },
      { id: 28, slug:'ward', name:'Koshary Ward', category:'Middle Eastern', desc:'Authentic Egyptian koshary with traditional recipes and generous portions.', rating:4.7, image: 'ward.png' },
      { id: 29, slug:'willys', name:'Willy\'s', category:'Burgers', desc:'Classic burgers with juicy patties and all your favorite toppings.', rating:4.5, image: 'willys.png' },
      { id: 30, slug:'pizza', name:'Pizza Hut', category:'Pizza', desc:'World-famous pizza chain with a variety of crusts and toppings.', rating:4.2, image: 'pizza.jpg' }
    ];

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      initializeApp();
    });

    // Initialize the application
    async function initializeApp() {
      // Check if user is logged in
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        // Redirect to login if not authenticated
        window.location.href = 'login.html';
        return;
      }
      
      currentUser = user;
      
      // Check if viewing own profile or another user's profile
      const urlParams = new URLSearchParams(window.location.search);
      targetUserId = urlParams.get('user');
      
      if (targetUserId && targetUserId !== user.id) {
        isViewingOwnProfile = false;
        targetUser = await getUserProfile(targetUserId);
        loadProfile(targetUser);
        document.getElementById('backButton').style.display = 'inline-block';
        document.getElementById('logoutBtn').style.display = 'none';
        document.getElementById('profileContainer').classList.add('view-only');
      } else {
        isViewingOwnProfile = true;
        userProfile = await getUserProfile(user.id);
        loadProfile(userProfile);
        document.getElementById('logoutBtn').style.display = 'inline-block';
      }
      
      // Initialize event listeners
      setupEventListeners();
      
      // Load user's restaurant lists
      loadRestaurantLists();
      
      // Initialize friend system
      friendSystem.init();
    }

    // Get user profile from database
    async function getUserProfile(userId) {
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();
      
      if (error) {
        console.error('Error fetching user profile:', error);
        return null;
      }
      
      return data;
    }

    // Load profile data into UI
    function loadProfile(profile) {
      if (!profile) return;
      
      document.getElementById('username').textContent = profile.username || 'User';
      document.getElementById('email').textContent = profile.email || '';
      document.getElementById('avatar').textContent = (profile.username || 'U').charAt(0).toUpperCase();
      document.getElementById('bioText').textContent = profile.bio || 'No bio yet. Click edit to add one!';
      document.getElementById('bioTextarea').value = profile.bio || '';
      
      // Format join date
      if (profile.created_at) {
        const joinDate = new Date(profile.created_at);
        document.getElementById('joinDate').textContent = `Joined ${joinDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
      }
      
      // Set privacy toggle
      document.getElementById('privacyToggle').checked = profile.is_private || false;
      document.getElementById('privacyLabel').textContent = profile.is_private ? 'Private Account' : 'Public Account';
      
      // Show/hide follow button if viewing another user's profile
      if (!isViewingOwnProfile) {
        document.getElementById('followButton').style.display = 'inline-block';
        updateFollowButton(profile);
      }
    }

    // Update follow button based on relationship status
    function updateFollowButton(profile) {
      const followButton = document.getElementById('followButton');
      
      // Check if current user is following this profile
      // This would need to query your follow relationships table
      const isFollowing = false; // Placeholder - implement actual check
      const hasRequested = false; // Placeholder - implement actual check
      
      if (isFollowing) {
        followButton.textContent = 'Following';
        followButton.classList.add('following');
      } else if (hasRequested) {
        followButton.textContent = 'Requested';
        followButton.classList.add('requested');
      } else {
        followButton.textContent = 'Follow';
        followButton.classList.remove('following', 'requested');
      }
    }

    // Setup event listeners
    function setupEventListeners() {
      // Bio editing
      document.getElementById('editBioBtn').addEventListener('click', toggleBioEdit);
      document.getElementById('cancelBioBtn').addEventListener('click', cancelBioEdit);
      document.getElementById('saveBioBtn').addEventListener('click', saveBio);
      
      // Privacy toggle
      document.getElementById('privacyToggle').addEventListener('change', togglePrivacy);
      
      // Logout
      document.getElementById('logoutBtn').addEventListener('click', logout);
      
      // Follow button
      document.getElementById('followButton').addEventListener('click', toggleFollow);
      
      // User search
      document.getElementById('userSearch').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          friendSystem.searchUsers();
        }
      });
    }

    // Bio editing functions
    function toggleBioEdit() {
      document.getElementById('bioDisplay').style.display = 'none';
      document.getElementById('bioEdit').style.display = 'block';
    }

    function cancelBioEdit() {
      document.getElementById('bioEdit').style.display = 'none';
      document.getElementById('bioDisplay').style.display = 'block';
      document.getElementById('bioTextarea').value = document.getElementById('bioText').textContent;
    }

    async function saveBio() {
      const newBio = document.getElementById('bioTextarea').value;
      
      const { error } = await supabase
        .from('profiles')
        .update({ bio: newBio })
        .eq('id', currentUser.id);
      
      if (error) {
        showNotification('Error updating bio', 'error');
        console.error('Error updating bio:', error);
      } else {
        document.getElementById('bioText').textContent = newBio || 'No bio yet. Click edit to add one!';
        document.getElementById('bioEdit').style.display = 'none';
        document.getElementById('bioDisplay').style.display = 'block';
        showNotification('Bio updated successfully', 'success');
      }
    }

    // Privacy toggle
    async function togglePrivacy() {
      const isPrivate = document.getElementById('privacyToggle').checked;
      
      const { error } = await supabase
        .from('profiles')
        .update({ is_private: isPrivate })
        .eq('id', currentUser.id);
      
      if (error) {
        showNotification('Error updating privacy settings', 'error');
        console.error('Error updating privacy:', error);
        // Revert the toggle
        document.getElementById('privacyToggle').checked = !isPrivate;
      } else {
        document.getElementById('privacyLabel').textContent = isPrivate ? 'Private Account' : 'Public Account';
        showNotification(`Account set to ${isPrivate ? 'private' : 'public'}`, 'success');
      }
    }

    // Follow/unfollow user
    async function toggleFollow() {
      if (!targetUser) return;
      
      const followButton = document.getElementById('followButton');
      const isFollowing = followButton.classList.contains('following');
      const hasRequested = followButton.classList.contains('requested');
      
      if (isFollowing) {
        // Unfollow user
        const { error } = await supabase
          .from('follows')
          .delete()
          .eq('follower_id', currentUser.id)
          .eq('following_id', targetUser.id);
        
        if (error) {
          showNotification('Error unfollowing user', 'error');
          console.error('Error unfollowing:', error);
        } else {
          followButton.textContent = 'Follow';
          followButton.classList.remove('following');
          showNotification(`Unfollowed ${targetUser.username}`, 'success');
          updateFollowCounts();
        }
      } else if (hasRequested) {
        // Cancel follow request
        const { error } = await supabase
          .from('follow_requests')
          .delete()
          .eq('requester_id', currentUser.id)
          .eq('target_id', targetUser.id);
        
        if (error) {
          showNotification('Error canceling follow request', 'error');
          console.error('Error canceling request:', error);
        } else {
          followButton.textContent = 'Follow';
          followButton.classList.remove('requested');
          showNotification('Follow request canceled', 'success');
        }
      } else {
        // Send follow request or follow directly if public account
        if (targetUser.is_private) {
          // Send follow request for private account
          const { error } = await supabase
            .from('follow_requests')
            .insert({
              requester_id: currentUser.id,
              target_id: targetUser.id
            });
          
          if (error) {
            showNotification('Error sending follow request', 'error');
            console.error('Error sending request:', error);
          } else {
            followButton.textContent = 'Requested';
            followButton.classList.add('requested');
            showNotification(`Follow request sent to ${targetUser.username}`, 'success');
          }
        } else {
          // Follow directly for public account
          const { error } = await supabase
            .from('follows')
            .insert({
              follower_id: currentUser.id,
              following_id: targetUser.id
            });
          
          if (error) {
            showNotification('Error following user', 'error');
            console.error('Error following:', error);
          } else {
            followButton.textContent = 'Following';
            followButton.classList.add('following');
            showNotification(`Following ${targetUser.username}`, 'success');
            updateFollowCounts();
          }
        }
      }
    }

    // Load restaurant lists
    async function loadRestaurantLists() {
      if (!isViewingOwnProfile && targetUser && targetUser.is_private) {
        // Check if current user follows target user
        const { data: followData } = await supabase
          .from('follows')
          .select('id')
          .eq('follower_id', currentUser.id)
          .eq('following_id', targetUser.id)
          .single();
        
        if (!followData) {
          // Show private message if not following
          document.getElementById('privateMessage').style.display = 'block';
          document.querySelector('.list-grid').style.display = 'none';
          return;
        }
      }
      
      // Get user's restaurant lists from database
      const { data: lists, error } = await supabase
        .from('user_restaurant_lists')
        .select('*')
        .eq('user_id', isViewingOwnProfile ? currentUser.id : targetUser.id);
      
      if (error) {
        console.error('Error fetching restaurant lists:', error);
        return;
      }
      
      // Count restaurants in each list
      const favoritesCount = lists?.filter(list => list.list_type === 'favorites').length || 0;
      const visitedCount = lists?.filter(list => list.list_type === 'visited').length || 0;
      const wantToGoCount = lists?.filter(list => list.list_type === 'wantToGo').length || 0;
      
      // Update UI
      document.getElementById('favoritesCount').textContent = `${favoritesCount} restaurants`;
      document.getElementById('visitedCount').textContent = `${visitedCount} restaurants`;
      document.getElementById('wantToGoCount').textContent = `${wantToGoCount} restaurants`;
    }

    // Show restaurant list
    async function showList(listType) {
      if (!isViewingOwnProfile && targetUser && targetUser.is_private) {
        // Check if current user follows target user
        const { data: followData } = await supabase
          .from('follows')
          .select('id')
          .eq('follower_id', currentUser.id)
          .eq('following_id', targetUser.id)
          .single();
        
        if (!followData) {
          return; // Don't show list if not following private account
        }
      }
      
      currentActiveList = listType;
      
      // Get restaurants in this list from database
      const { data: listItems, error } = await supabase
        .from('user_restaurant_lists')
        .select('restaurant_id')
        .eq('user_id', isViewingOwnProfile ? currentUser.id : targetUser.id)
        .eq('list_type', listType);
      
      if (error) {
        console.error('Error fetching list items:', error);
        return;
      }
      
      const restaurantIds = listItems.map(item => item.restaurant_id);
      const listRestaurants = restaurants.filter(restaurant => 
        restaurantIds.includes(restaurant.id)
      );
      
      // Update UI
      document.querySelector('.list-grid').style.display = 'none';
      document.getElementById('activeListSection').style.display = 'block';
      
      // Set list title
      const listTitles = {
        'favorites': 'Favorites',
        'visited': 'Visited',
        'wantToGo': 'Want to Go'
      };
      document.getElementById('activeListTitle').textContent = listTitles[listType];
      
      // Render restaurants
      const grid = document.getElementById('activeListGrid');
      grid.innerHTML = '';
      
      if (listRestaurants.length === 0) {
        grid.innerHTML = `
          <div class="empty-state">
            <div>üçΩÔ∏è</div>
            <p>No restaurants in this list yet</p>
          </div>
        `;
        return;
      }
      
      listRestaurants.forEach(restaurant => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.innerHTML = `
          <div class="media">
            <img src="images/restaurants/${restaurant.image}" alt="${restaurant.name}" onerror="this.src='images/restaurants/default.jpg'">
          </div>
          <div class="inner">
            <h3>${restaurant.name}</h3>
            <p class="category">${restaurant.category}</p>
            <p class="rating">‚≠ê ${restaurant.rating}</p>
            <p class="desc">${restaurant.desc}</p>
          </div>
          ${isViewingOwnProfile ? `
            <div class="list-actions">
              <button class="list-btn" onclick="removeFromList(${restaurant.id}, '${listType}')">
                <i class="fas fa-times"></i>
              </button>
            </div>
          ` : ''}
        `;
        grid.appendChild(tile);
      });
    }

    // Hide active list and show list grid
    function hideActiveList() {
      document.getElementById('activeListSection').style.display = 'none';
      document.querySelector('.list-grid').style.display = 'grid';
      currentActiveList = null;
    }

    // Remove restaurant from list
    async function removeFromList(restaurantId, listType) {
      const { error } = await supabase
        .from('user_restaurant_lists')
        .delete()
        .eq('user_id', currentUser.id)
        .eq('restaurant_id', restaurantId)
        .eq('list_type', listType);
      
      if (error) {
        showNotification('Error removing restaurant from list', 'error');
        console.error('Error removing from list:', error);
      } else {
        showNotification('Restaurant removed from list', 'success');
        // Refresh the list display
        showList(listType);
        // Update list counts
        loadRestaurantLists();
      }
    }

    // Friend System
    const friendSystem = {
      init: function() {
        this.updateFollowCounts();
      },
      
      updateFollowCounts: async function() {
        if (!isViewingOwnProfile) return;
        
        // Get follower count
        const { data: followers, error: followersError } = await supabase
          .from('follows')
          .select('id')
          .eq('following_id', currentUser.id);
        
        // Get following count
        const { data: following, error: followingError } = await supabase
          .from('follows')
          .select('id')
          .eq('follower_id', currentUser.id);
        
        // Get follow requests count
        const { data: requests, error: requestsError } = await supabase
          .from('follow_requests')
          .select('id')
          .eq('target_id', currentUser.id);
        
        if (!followersError) {
          document.getElementById('followersCount').textContent = followers?.length || 0;
        }
        
        if (!followingError) {
          document.getElementById('followingCount').textContent = following?.length || 0;
        }
        
        if (!requestsError) {
          document.getElementById('requestsCount').textContent = requests?.length || 0;
        }
      },
      
      searchUsers: async function() {
        const searchTerm = document.getElementById('userSearch').value.trim();
        
        if (!searchTerm) {
          showNotification('Please enter a search term', 'error');
          return;
        }
        
        const { data: users, error } = await supabase
          .from('profiles')
          .select('id, username, email, bio, is_private')
          .ilike('username', `%${searchTerm}%`)
          .limit(10);
        
        if (error) {
          console.error('Error searching users:', error);
          showNotification('Error searching users', 'error');
          return;
        }
        
        this.displayUsers(users);
        currentSocialView = 'search';
      },
      
      showFollowers: async function() {
        if (!isViewingOwnProfile) return;
        
        const { data: followers, error } = await supabase
          .from('follows')
          .select(`
            follower:profiles!follows_follower_id_fkey(id, username, email, bio)
          `)
          .eq('following_id', currentUser.id);
        
        if (error) {
          console.error('Error fetching followers:', error);
          return;
        }
        
        const followerUsers = followers.map(f => f.follower);
        this.displayUsers(followerUsers, 'followers');
        currentSocialView = 'followers';
      },
      
      showFollowing: async function() {
        if (!isViewingOwnProfile) return;
        
        const { data: following, error } = await supabase
          .from('follows')
          .select(`
            following:profiles!follows_following_id_fkey(id, username, email, bio)
          `)
          .eq('follower_id', currentUser.id);
        
        if (error) {
          console.error('Error fetching following:', error);
          return;
        }
        
        const followingUsers = following.map(f => f.following);
        this.displayUsers(followingUsers, 'following');
        currentSocialView = 'following';
      },
      
      showRequests: async function() {
        if (!isViewingOwnProfile) return;
        
        const { data: requests, error } = await supabase
          .from('follow_requests')
          .select(`
            requester:profiles!follow_requests_requester_id_fkey(id, username, email, bio)
          `)
          .eq('target_id', currentUser.id);
        
        if (error) {
          console.error('Error fetching requests:', error);
          return;
        }
        
        const requestUsers = requests.map(r => r.requester);
        this.displayUsers(requestUsers, 'requests');
        currentSocialView = 'requests';
      },
      
      displayUsers: function(users, viewType = 'search') {
        const userLists = document.getElementById('userLists');
        
        if (!users || users.length === 0) {
          userLists.innerHTML = `
            <div class="empty-state">
              <div>üë•</div>
              <p>No users found</p>
            </div>
          `;
          return;
        }
        
        userLists.innerHTML = '';
        
        users.forEach(user => {
          if (user.id === currentUser.id) return; // Skip current user
          
          const userCard = document.createElement('div');
          userCard.className = 'user-card';
          
          // Determine action button based on view type and relationship
          let actionButton = '';
          
          if (viewType === 'search') {
            // Check if already following
            // This would need to query your follows table
            const isFollowing = false; // Placeholder
            const hasRequested = false; // Placeholder
            
            if (isFollowing) {
              actionButton = `<button class="action-btn following-action" onclick="friendSystem.unfollowUser('${user.id}')">Following</button>`;
            } else if (hasRequested) {
              actionButton = `<button class="action-btn requested-action" onclick="friendSystem.cancelRequest('${user.id}')">Requested</button>`;
            } else {
              actionButton = `<button class="action-btn follow-action" onclick="friendSystem.followUser('${user.id}')">Follow</button>`;
            }
          } else if (viewType === 'followers') {
            actionButton = `
              <button class="action-btn follow-action" onclick="friendSystem.followUser('${user.id}')">Follow Back</button>
              <button class="action-btn reject-btn" onclick="friendSystem.removeFollower('${user.id}')">Remove</button>
            `;
          } else if (viewType === 'following') {
            actionButton = `<button class="action-btn reject-btn" onclick="friendSystem.unfollowUser('${user.id}')">Unfollow</button>`;
          } else if (viewType === 'requests') {
            actionButton = `
              <button class="action-btn accept-btn" onclick="friendSystem.acceptRequest('${user.id}')">Accept</button>
              <button class="action-btn reject-btn" onclick="friendSystem.rejectRequest('${user.id}')">Reject</button>
            `;
          }
          
          userCard.innerHTML = `
            <div class="user-card-header">
              <div class="user-avatar">${user.username?.charAt(0).toUpperCase() || 'U'}</div>
              <div class="user-info">
                <div class="user-name" onclick="viewUserProfile('${user.id}')">${user.username || 'User'}</div>
                <div class="user-bio">${user.bio || 'No bio yet'}</div>
              </div>
            </div>
            <div class="user-actions">
              ${actionButton}
            </div>
          `;
          
          userLists.appendChild(userCard);
        });
      },
      
      followUser: async function(userId) {
        const user = await getUserProfile(userId);
        
        if (!user) {
          showNotification('User not found', 'error');
          return;
        }
        
        if (user.is_private) {
          // Send follow request for private account
          const { error } = await supabase
            .from('follow_requests')
            .insert({
              requester_id: currentUser.id,
              target_id: userId
            });
          
          if (error) {
            showNotification('Error sending follow request', 'error');
            console.error('Error sending request:', error);
          } else {
            showNotification(`Follow request sent to ${user.username}`, 'success');
            // Refresh the display
            if (currentSocialView === 'search') {
              this.searchUsers();
            }
          }
        } else {
          // Follow directly for public account
          const { error } = await supabase
            .from('follows')
            .insert({
              follower_id: currentUser.id,
              following_id: userId
            });
          
          if (error) {
            showNotification('Error following user', 'error');
            console.error('Error following:', error);
          } else {
            showNotification(`Following ${user.username}`, 'success');
            // Refresh the display and counts
            this.updateFollowCounts();
            if (currentSocialView === 'search') {
              this.searchUsers();
            } else if (currentSocialView === 'followers') {
              this.showFollowers();
            }
          }
        }
      },
      
      unfollowUser: async function(userId) {
        const { error } = await supabase
          .from('follows')
          .delete()
          .eq('follower_id', currentUser.id)
          .eq('following_id', userId);
        
        if (error) {
          showNotification('Error unfollowing user', 'error');
          console.error('Error unfollowing:', error);
        } else {
          showNotification('User unfollowed', 'success');
          // Refresh the display and counts
          this.updateFollowCounts();
          if (currentSocialView === 'search') {
            this.searchUsers();
          } else if (currentSocialView === 'following') {
            this.showFollowing();
          }
        }
      },
      
      cancelRequest: async function(userId) {
        const { error } = await supabase
          .from('follow_requests')
          .delete()
          .eq('requester_id', currentUser.id)
          .eq('target_id', userId);
        
        if (error) {
          showNotification('Error canceling follow request', 'error');
          console.error('Error canceling request:', error);
        } else {
          showNotification('Follow request canceled', 'success');
          // Refresh the display
          if (currentSocialView === 'search') {
            this.searchUsers();
          }
        }
      },
      
      acceptRequest: async function(userId) {
        // Add to follows table
        const { error: followError } = await supabase
          .from('follows')
          .insert({
            follower_id: userId,
            following_id: currentUser.id
          });
        
        if (followError) {
          showNotification('Error accepting follow request', 'error');
          console.error('Error accepting request:', followError);
          return;
        }
        
        // Remove from follow_requests table
        const { error: requestError } = await supabase
          .from('follow_requests')
          .delete()
          .eq('requester_id', userId)
          .eq('target_id', currentUser.id);
        
        if (requestError) {
          showNotification('Error completing follow request', 'error');
          console.error('Error removing request:', requestError);
          return;
        }
        
        showNotification('Follow request accepted', 'success');
        // Refresh the display and counts
        this.updateFollowCounts();
        this.showRequests();
      },
      
      rejectRequest: async function(userId) {
        const { error } = await supabase
          .from('follow_requests')
          .delete()
          .eq('requester_id', userId)
          .eq('target_id', currentUser.id);
        
        if (error) {
          showNotification('Error rejecting follow request', 'error');
          console.error('Error rejecting request:', error);
        } else {
          showNotification('Follow request rejected', 'success');
          // Refresh the display
          this.showRequests();
        }
      },
      
      removeFollower: async function(userId) {
        const { error } = await supabase
          .from('follows')
          .delete()
          .eq('follower_id', userId)
          .eq('following_id', currentUser.id);
        
        if (error) {
          showNotification('Error removing follower', 'error');
          console.error('Error removing follower:', error);
        } else {
          showNotification('Follower removed', 'success');
          // Refresh the display and counts
          this.updateFollowCounts();
          this.showFollowers();
        }
      }
    };

    // View user profile
    function viewUserProfile(userId) {
      window.location.href = `profile.html?user=${userId}`;
    }

    // Go back to previous page
    function goBack() {
      window.history.back();
    }

    // Logout
    async function logout() {
      const { error } = await supabase.auth.signOut();
      if (error) {
        console.error('Error signing out:', error);
      } else {
        window.location.href = 'login.html';
      }
    }

    // Show notification
    function showNotification(message, type = 'info') {
      const notification = document.getElementById('customNotification');
      const icon = notification.querySelector('.notification-icon');
      const messageEl = notification.querySelector('.notification-message');
      
      // Set notification content and style
      messageEl.textContent = message;
      notification.className = `custom-notification notification-${type}`;
      
      // Set icon based on type
      if (type === 'success') {
        icon.className = 'notification-icon fas fa-check-circle';
      } else if (type === 'error') {
        icon.className = 'notification-icon fas fa-exclamation-circle';
      } else {
        icon.className = 'notification-icon fas fa-info-circle';
      }
      
      // Show notification
      notification.classList.add('notification-show');
      
      // Hide after 3 seconds
      setTimeout(() => {
        notification.classList.remove('notification-show');
      }, 3000);
    }
  </script>
</body>
</html>