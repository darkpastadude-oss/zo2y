begin;

create extension if not exists pgcrypto;

alter table if exists public.user_profiles
  add column if not exists profile_theme text not null default 'navy';

alter table if exists public.user_profiles
  add column if not exists profile_badges jsonb not null default '[]'::jsonb;

update public.user_profiles
set
  profile_theme = coalesce(nullif(trim(profile_theme), ''), 'navy'),
  profile_badges = coalesce(profile_badges, '[]'::jsonb)
where true;

create table if not exists public.profile_pinned_lists (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  media_type text not null check (media_type in ('restaurant', 'movie', 'tv', 'game', 'book', 'music')),
  list_id text not null,
  list_type text not null default 'custom' check (list_type in ('default', 'custom')),
  sort_order integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, media_type, list_id, list_type)
);

create index if not exists idx_profile_pinned_lists_lookup
  on public.profile_pinned_lists (user_id, media_type, sort_order);

create table if not exists public.home_spotlight_cache (
  cache_key text primary key,
  feed_payload jsonb not null default '{}'::jsonb,
  generated_at timestamptz not null default now(),
  expires_at timestamptz not null default (now() + interval '20 minutes'),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_home_spotlight_cache_expiry
  on public.home_spotlight_cache (expires_at desc);

create or replace function public.zo2y_set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists profile_pinned_lists_set_updated_at on public.profile_pinned_lists;
create trigger profile_pinned_lists_set_updated_at
before update on public.profile_pinned_lists
for each row execute function public.zo2y_set_updated_at();

drop trigger if exists home_spotlight_cache_set_updated_at on public.home_spotlight_cache;
create trigger home_spotlight_cache_set_updated_at
before update on public.home_spotlight_cache
for each row execute function public.zo2y_set_updated_at();

alter table public.profile_pinned_lists enable row level security;
alter table public.home_spotlight_cache enable row level security;

drop policy if exists profile_pinned_lists_select_auth on public.profile_pinned_lists;
create policy profile_pinned_lists_select_auth
on public.profile_pinned_lists for select
to authenticated
using (true);

drop policy if exists profile_pinned_lists_insert_owner on public.profile_pinned_lists;
create policy profile_pinned_lists_insert_owner
on public.profile_pinned_lists for insert
to authenticated
with check (auth.uid() = user_id);

drop policy if exists profile_pinned_lists_update_owner on public.profile_pinned_lists;
create policy profile_pinned_lists_update_owner
on public.profile_pinned_lists for update
to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists profile_pinned_lists_delete_owner on public.profile_pinned_lists;
create policy profile_pinned_lists_delete_owner
on public.profile_pinned_lists for delete
to authenticated
using (auth.uid() = user_id);

drop policy if exists home_spotlight_cache_select_public on public.home_spotlight_cache;
create policy home_spotlight_cache_select_public
on public.home_spotlight_cache for select
to anon, authenticated
using (true);

drop policy if exists home_spotlight_cache_service_insert on public.home_spotlight_cache;
create policy home_spotlight_cache_service_insert
on public.home_spotlight_cache for insert
to authenticated
with check (auth.role() = 'service_role');

drop policy if exists home_spotlight_cache_service_update on public.home_spotlight_cache;
create policy home_spotlight_cache_service_update
on public.home_spotlight_cache for update
to authenticated
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists home_spotlight_cache_service_delete on public.home_spotlight_cache;
create policy home_spotlight_cache_service_delete
on public.home_spotlight_cache for delete
to authenticated
using (auth.role() = 'service_role');

grant usage on schema public to anon, authenticated;
grant select on public.home_spotlight_cache to anon, authenticated;
grant select, insert, update, delete on public.profile_pinned_lists to authenticated;
grant usage, select on sequence public.profile_pinned_lists_id_seq to authenticated;

create or replace function public.set_home_spotlight_cache(
  p_feed_payload jsonb,
  p_cache_key text default 'global',
  p_ttl_minutes integer default 20
)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  safe_payload jsonb := coalesce(p_feed_payload, '{}'::jsonb);
  safe_cache_key text := coalesce(nullif(trim(p_cache_key), ''), 'global');
  safe_ttl integer := greatest(1, coalesce(p_ttl_minutes, 20));
begin
  insert into public.home_spotlight_cache (
    cache_key,
    feed_payload,
    generated_at,
    expires_at
  )
  values (
    safe_cache_key,
    safe_payload,
    now(),
    now() + make_interval(mins => safe_ttl)
  )
  on conflict (cache_key) do update
  set
    feed_payload = excluded.feed_payload,
    generated_at = excluded.generated_at,
    expires_at = excluded.expires_at,
    updated_at = now();
end;
$$;

insert into public.home_spotlight_cache (cache_key, feed_payload, generated_at, expires_at)
values ('global', '{}'::jsonb, now(), now() + interval '20 minutes')
on conflict (cache_key) do nothing;

commit;
