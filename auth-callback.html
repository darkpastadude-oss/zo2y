<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="index,follow,max-image-preview:none,noimageindex" />
  <title>Processing Authentication - Zo2y</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body {
      background: #0b1633;
      color: white;
      font-family: 'Poppins', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    .container {
      text-align: center;
      padding: 40px;
      background: #132347;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      max-width: 400px;
    }
    .spinner {
      border: 4px solid rgba(255,255,255,0.1);
      border-top: 4px solid #f59e0b;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .success {
      color: #10b981;
      font-size: 3rem;
      margin-bottom: 20px;
    }
    .error {
      color: #fca5a5;
      margin-top: 12px;
      font-size: 14px;
    }
    .debug {
      margin-top: 20px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      font-size: 12px;
      text-align: left;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      display: none;
    }
    .debug.show { display: block; }
    .debug-line { margin-bottom: 5px; color: #00ff00; }
    .debug-error { color: #ff0000; }
  </style>
  <meta name="theme-color" content="#0b1633" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Zo2y" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/images/logo.png" />
  <link rel="stylesheet" href="/js/mobile-app.css?v=20260225b" />
  <script src="/js/mobile-webapp.js?v=20260225d" defer></script>
</head>
<body>
  <div class="container">
    <div class="spinner"></div>
    <h2>Completing Authentication...</h2>
    <p id="statusText">Please wait while we set up your account.</p>
    <p id="errorText" class="error" style="display:none;"></p>
    <div id="debugConsole" class="debug"></div>
  </div>
  <script>
    (async function () {
      const SUPABASE_URL = 'https://gfkhjbztayjyojsgdpgk.supabase.co';
      const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdma2hqYnp0YXlqeW9qc2dkcGdrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwOTYyNjQsImV4cCI6MjA3NTY3MjI2NH0.WUb2yDAwCeokdpWCPeH13FE8NhWF6G8e6ivTsgu6b2s';
      const statusText = document.getElementById('statusText');
      const errorText = document.getElementById('errorText');
      const debugConsole = document.getElementById('debugConsole');

      const storedNext = localStorage.getItem('postAuthRedirect');
      const next = sanitizeNextPath(new URLSearchParams(window.location.search).get('next') || storedNext || 'index.html');
      const debugEnabled = window.location.search.includes('debug=true');
      if (debugEnabled) debugConsole.classList.add('show');

      function log(msg, isError = false) {
        console.log(msg);
        if (debugEnabled) {
          const line = document.createElement('div');
          line.className = isError ? 'debug-line debug-error' : 'debug-line';
          line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
          debugConsole.appendChild(line);
          debugConsole.scrollTop = debugConsole.scrollHeight;
        }
      }

      function sanitizeNextPath(raw) {
        const value = String(raw || '').trim();
        if (!value) return 'index.html';
        if (/^https?:\/\//i.test(value) || value.startsWith('//')) return 'index.html';
        if (value.startsWith('/')) return value.slice(1) || 'index.html';
        return value;
      }

      function getHashParams() {
        const hash = window.location.hash.startsWith('#') ? window.location.hash.slice(1) : '';
        return new URLSearchParams(hash);
      }

      function cleanUsername(value) {
        const base = String(value || '')
          .toLowerCase()
          .replace(/\s+/g, '_')
          .replace(/[^a-z0-9_]/g, '')
          .replace(/_+/g, '_')
          .replace(/^_+|_+$/g, '');
        return (base || 'user').slice(0, 30);
      }

      function usernameWithSuffix(base, suffix) {
        const normalizedSuffix = cleanUsername(suffix).slice(0, 8) || 'user';
        const limit = Math.max(3, 30 - normalizedSuffix.length - 1);
        return `${base.slice(0, limit)}_${normalizedSuffix}`;
      }

      async function waitForVerifiedUser(client) {
        let refreshAttempted = false;
        for (let attempt = 0; attempt < 4; attempt += 1) {
          const { data: sessionData } = await client.auth.getSession();
          const session = sessionData?.session || null;
          if (!session) {
            if (attempt < 3) {
              await new Promise((resolve) => setTimeout(resolve, 300));
              continue;
            }
            return null;
          }

          const { data: userData, error: userError } = await client.auth.getUser();
          if (!userError && userData?.user) return userData.user;

          const errorMessage = String(userError?.message || '').toLowerCase();
          const invalidSession =
            userError?.status === 401 ||
            errorMessage.includes('jwt') ||
            errorMessage.includes('token') ||
            errorMessage.includes('session') ||
            errorMessage.includes('unauthorized');

          if (invalidSession) {
            if (!refreshAttempted) {
              refreshAttempted = true;
              const { data: refreshed, error: refreshError } = await client.auth.refreshSession();
              if (!refreshError && refreshed?.session?.user) return refreshed.session.user;
            }
          }

          if (attempt < 3) {
            await new Promise((resolve) => setTimeout(resolve, 300));
          }
        }
        return null;
      }

      function getOnboardingPendingKey(userId) {
        return `zo2y_onboarding_pending_v1_${String(userId || '').trim()}`;
      }

      async function ensureUserProfile(client, user) {
        try {
          log('Checking if profile exists...');
          const { data: existingProfile, error: checkError } = await client
            .from('user_profiles')
            .select('id, username, full_name')
            .eq('id', user.id)
            .maybeSingle();

          if (existingProfile) {
            log(`Profile found: ${existingProfile.username || '(no username)'}`);
            return { ok: true, created: false };
          }

          if (checkError) {
            log(`Profile lookup warning: ${checkError.message}`, true);
          }

          const userData = user.user_metadata || {};
          const emailPrefix = String(user.email || '').split('@')[0] || 'user';
          const baseUsername = cleanUsername(
            userData.preferred_username ||
            userData.user_name ||
            userData.full_name ||
            userData.name ||
            emailPrefix
          );
          const displayName = String(userData.full_name || userData.name || emailPrefix || baseUsername).slice(0, 80);
          const idSuffix = String(user.id || '').replace(/-/g, '').slice(0, 6) || 'user';
          const usernameCandidates = [
            baseUsername,
            usernameWithSuffix(baseUsername, idSuffix),
            usernameWithSuffix(baseUsername, `${idSuffix}${Date.now().toString().slice(-2)}`)
          ];

          for (const username of usernameCandidates) {
            const profileData = {
              id: user.id,
              username,
              full_name: displayName || username
            };

            const { error: createError } = await client
              .from('user_profiles')
              .insert([profileData]);

            if (!createError) {
              log(`Profile created with username: ${username}`);
              return { ok: true, created: true };
            }

            const createMessage = String(createError.message || '').toLowerCase();
            const maybeDuplicate = createMessage.includes('duplicate') || createMessage.includes('unique');
            if (!maybeDuplicate) {
              log(`Profile creation error: ${createError.message}`, true);
              return { ok: false, created: false };
            }

            const { data: raceProfile } = await client
              .from('user_profiles')
              .select('id')
              .eq('id', user.id)
              .maybeSingle();

            if (raceProfile?.id) {
              log('Profile already created by another request.');
              return { ok: true, created: false };
            }
          }

          log('Could not create a unique username for profile.', true);
          return { ok: false, created: false };
        } catch (error) {
          log(`Profile setup error: ${error.message}`, true);
          return { ok: false, created: false };
        }
      }

      try {
        log('Initializing auth callback...');
        if (!window.supabase || !window.supabase.createClient) {
          throw new Error('Auth library unavailable');
        }

        const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
          auth: {
            flowType: 'pkce',
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: false
          }
        });

        const params = new URLSearchParams(window.location.search);
        const oauthError = params.get('error_description') || params.get('error');
        if (oauthError) {
          throw new Error(oauthError);
        }

        const code = params.get('code');
        const hashParams = getHashParams();
        const accessToken = hashParams.get('access_token');
        const refreshToken = hashParams.get('refresh_token');

        if (code) {
          statusText.textContent = 'Finalizing secure sign-in...';
          log('Auth code found, exchanging for session...');
          const { error } = await client.auth.exchangeCodeForSession(code);
          if (error) throw error;
        } else if (accessToken && refreshToken) {
          statusText.textContent = 'Finalizing secure sign-in...';
          log('Token hash found, setting session...');
          const { error } = await client.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken
          });
          if (error) throw error;
        } else {
          log('No code/hash provided, verifying existing session...');
        }

        const user = await waitForVerifiedUser(client);
        if (!user) {
          throw new Error('Authentication was not completed. Please sign in again.');
        }

        log(`Authenticated user: ${user.id}`);
        statusText.textContent = 'Setting up your profile...';
        const profileResult = await ensureUserProfile(client, user);
        if (profileResult?.created) {
          localStorage.setItem(getOnboardingPendingKey(user.id), '1');
        }

        statusText.textContent = 'Success! Redirecting...';
        localStorage.removeItem('postAuthRedirect');
        localStorage.removeItem('oauthFlow');
        log(`Redirecting to: ${next}`);
        setTimeout(() => {
          window.location.replace(next);
        }, 800);
      } catch (err) {
        const msg = (err && err.message) ? err.message : 'Authentication failed';
        log(`Fatal error: ${msg}`, true);
        statusText.textContent = 'Could not complete authentication.';
        errorText.textContent = msg;
        errorText.style.display = 'block';
        setTimeout(() => {
          window.location.replace('login.html');
        }, 2500);
      }
    })();
  </script>
  <script src="js/production-runtime.js?v=20260221a" defer></script>
</body>
</html>






